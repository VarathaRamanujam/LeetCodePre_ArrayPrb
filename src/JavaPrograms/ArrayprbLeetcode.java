package JavaPrograms;

import java.util.*;

public class ArrayprbLeetcode {
    public static void main(String[] args) {
        //int arr[] = {9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9};
        //plusOnePrb(arr);

//        int nums[] = {3,2,3};
//        System.out.println( majorityElement(nums));

//        String arr[] = {"eat","tea","tan","ate","nat","bat"};
//        System.out.println(groupAnagrams(arr));

//        String arr[] = {"abba","baba","bbaa","cd","cd"};
//        System.out.println(removeAnagrams(arr));

//        String s = "leetcode"; String ss ="coats";
//        System.out.println( minSteps(s,ss));

//        String s = "abab"; String ss ="ab";
//        System.out.println(findAnagrams(s,ss));

       // spiralOrder();// need to finish

//        int [] arr = {2,2,3,2};
//        System.out.println(singleNumber(arr));

//        int arr[] = {4,2,3,0,3,1,2};
//        System.out.println(rec1306(arr,0));

//          int arr[] = {4,3,1,1,3,3,2};
//          System.out.println(findLeastNumOfUniqueInts(arr, 4));

//          int arr[] ={1,1,1,1,1};
//          System.out.println(jumpMediumGame(arr));

//        int[] nums = {1,3,4,8,7,9,3,5,1};
//        int[][] arr = divideArray(nums,2);
//        for (int i = 0; i < arr.length; i++) {
//            for (int j = 0; j < arr[i].length; j++) {
//                System.out.print(arr[i][j]+" ");
//            }
//            System.out.println();
//        }

//        int[][] matrix= {{1,2,3,4},{5,6,7,8},{9,10,11,12}};
//        System.out.println(Arrays.asList(spiralOrder(matrix)));

//        int[] values = {3,0,2,6,8,1,7,9,4,2,5,5,0};
//        ListNode head = new ListNode(values);
//        int arr[][] = spiralMatrix(3,5, head);
//          for (int i = 0; i < arr.length; i++) {
//            for (int j = 0; j < arr[i].length; j++) {
//                System.out.print(arr[i][j]+" ");
//            }
//            System.out.println();
//        }

//        int nums1[]={1,3};
//        int nums2[]={2};
//        findMedianSortedArrays(nums1,nums2);

        //spiralMatrix(1,2);//need to finish

       // rotate(new int[]{1,2},2);
       // System.out.println(findMin(new int[]{3,4,5,1,2}));

       // System.out.println(removeDuplicates(new int[]{-3,-1,0,0,0,3,3}));

       // System.out.println(Arrays.toString(sortPeople(new  String[]{"IEO","Sgizfdfrims","QTASHKQ","Vk","RPJOFYZUBFSIYp","EPCFFt","VOYGWWNCf","WSpmqvb"}, new int[]{17233,32521,14087,42738,46669,65662,43204,8224})));

        //  sortTheStudents(new int[][]{{26063,77277,24329,97449,83641,98499,99037,73504,35216,21060},{79689,20580,86773,52964,84323,78255,42425,20990,74117,1685},{78047,83048,30042,95812,56302,77661,95589,51556,83830,2765},{70023,9694,63807,23997,967,71957,55944,46460,4003,61615},{90149,53227,97853,73362,27354,60268,57710,99030,5226,46597},{80916,99369,90239,55759,95899,64117,50449,43677,63001,14245},{84407,92198,61438,66791,16945,16469,35322,46244,78847,6529},{97658,46783,86167,18462,29233,89548,1402,4549,23593,60733},{89982,41773,52974,46354,3821,16637,1718,96385,5214,63120},{14928,38392,35017,62313,91433,34791,29599,69491,35111,8683}},2);

           // frequencySort(new int[]{1,1,2,2,2,3,4,0,0,0});

          //  frequencySort("tree");

          //  topKFrequent(new int[]{1,1,1,2,2,3}, 2);

          //  topKFrequent(new String[]{"rmrypv","zgsedk","jlmetsplg","wnfbo","hnnftqf","bxlr","sviavwoxss","jdbgvc","zddeno","rxgw","hnnftqf","hdmvplne","rlmdt","jlmetsplg","ous","rmrypv","fwxulnpit","dmhuq","rxgw","ledleb","bxlr","indbvb","ckqqibnx","cub","ijww","ehd","hfhlfqzkcn","sviavwoxss","rxgw","bxjxpfp","mgqj","oic","ptk","fwxulnpit","ijww","sviavwoxss","bgfvfa","zfkgsudxq","alkq","dmhuq","zddeno","rxgw","zgsedk","amarxpg","bgfvfa","wnfbo","sviavwoxss","sviavwoxss","alkq","nmclxk","zgsedk","bwowfvira","ous","bxlr","zddeno","rxgw","ous","wnfbo","rmrypv","sviavwoxss","ehd","zgsedk","jlmetsplg","abxvhyehv","ledleb","wnfbo","bgfvfa","bwowfvira","amarxpg","wnfbo","bwowfvira","dmhuq","ouy","bxlr","rxgw","oic","hnnftqf","ledleb","rlmdt","oldainprua","ous","ckqqibnx","dmhuq","hnnftqf","oic","jlmetsplg","ppn","amarxpg","jlgfgwb","bxlr","bwowfvira","hdmvplne","oic","ledleb","bwowfvira","oic","ptk","dmhuq","abxvhyehv","ckqqibnx","indbvb","ypzfk","rmrypv","bxjxpfp","amarxpg","dmhuq","sviavwoxss","bwowfvira","zfkgsudxq","wnfbo","rxgw","jxkvrmajri","cub","abxvhyehv","bwowfvira","indbvb","ehd","ckqqibnx","oic","ptk","hnnftqf","ouy","oic","zgsedk","abxvhyehv","ypzfk","ptk","sviavwoxss","rmrypv","oic","ous","abxvhyehv","hnnftqf","hfhlfqzkcn","ledleb","cub","ppn","zddeno","indbvb","oic","jlmetsplg","ouy","bwowfvira","bklij","gucayxp","zfkgsudxq","hfhlfqzkcn","zddeno","ledleb","zfkgsudxq","hnnftqf","bgfvfa","jlmetsplg","indbvb","ehd","wnfbo","hnnftqf","rlmdt","bxlr","indbvb","jdbgvc","jlmetsplg","cub","jlgfgwb","ypzfk","indbvb","dmhuq","jlmetsplg","zgsedk","rmrypv","cub","rxgw","ledleb","rxgw","sviavwoxss","ckqqibnx","hdmvplne","dmhuq","wnfbo","jlmetsplg","bxlr","zfkgsudxq","bxjxpfp","ledleb","indbvb","ckqqibnx","ous","ckqqibnx","cub","ous","abxvhyehv","bxlr","hfhlfqzkcn","hfhlfqzkcn","oic","ten","amarxpg","indbvb","cub","alkq","alkq","sviavwoxss","indbvb","bwowfvira","ledleb"},41);

        //percentageLetter("foobar",'o');

        //findKthLargest(new int[]{2147483647,-2147483648,1,5,6,3},2);

        //maxPower("ccbccbb");

        //setZeroes(new int[][]{{0,1,2,0},{3,4,5,2},{1,3,1,5}});

        //System.out.println(subarraySum(new int[]{1,1,1},2));

        //rotateTraverse(new int[][]{{1,2,3},{4,5,6},{7,8,9}});

       // System.out.println(singleNonDuplicate(new int[]{3,3,7,7,10,11,11}));

        //System.out.println(pivotIndex(new int[]{1,7,3,6,5,6}));

        //System.out.println(Arrays.toString(getSecondOrderElements(new int[]{1,2,3,4,5,6,7,8,9,10})));

        //System.out.println(Arrays.toString(moveZeros(new int[]{38,7 ,93, 0, 8, 15, 0, 0, 0, 0, 0, 26, 0,  0, 43, 90, 2, 0, 0, 0, 58, 94, 77, 45, 59, 19, 0, 0, 98, 0, 0, 0, 0, 0, 88, 0, 0, 0,100})));// need to complete

//        ArrayList<Integer> arr = new ArrayList<>();
//        arr.add(1); arr.add(2);
//        System.out.println(rotateArray(arr,1));

       // System.out.println(sortedArray(new int[]{1,2,3,3}, new int[]{2,2,4}));

        //System.out.println(longestSubarrayWithSumK(new int[]{-1 ,0 ,1 ,1 ,-1 ,-1 ,0},0));

        //System.out.println(longestConsecutive(new int[]{0,3,7,2,5,8,4,6,0,1}));

        //majorityElement11(new int[]{3,2,3});

        //System.out.println(characterReplacement("BAAABAB",3));

       // System.out.println(calculateTax(new int[][]{{1,0},{4,25},{5,50}},2));

        //System.out.println(longestValidParentheses("(()()"));

        //System.out.println(count(new int[]{1,1,1,2,2,3,3}, 1));

        //System.out.println ( longestOnes(new int[]{0,0,0,0},0));

       // System.out.println(maximumOddBinaryNumber("11010"));

       // iterationInArraySubSet();

//        List<List<Integer>> ls = new ArrayList<>();
//        List<Integer> arr = new ArrayList<>();
//        arr.add(1); arr.add(2); arr.add(3);
//        recInArraySubSet(ls, arr, new ArrayList<>());
//        System.out.println(ls);

//        List<String> res =wordSubsets(new String[]{"amazon","apple","facebook","google","leetcode"}, new String[]{"e","oo"});
//        System.out.println(res);

        //List<List<Integer>> res = threeSum(new int[]{0,0,0});
        //System.out.println(res);

        //System.out.println(threeSumClosest(new int[]{1,2,7,13}, 12));

        //System.out.println(lengthOfLongestSubstring("abcabcbb"));

        System.out.println(bagOfTokensScore(new int[]{200,100},150));

       // System.out.println(checkSubarraySum(new int[]{23,2,4,6,6},7)); //need to work
    }

    public static int bagOfTokensScore(int[] tokens, int power) {
        //Arrays.sort(tokens);
        int lf = 0; int rt = tokens.length-1;
        quickSort(tokens, lf, rt);
        int score = 0; int max = 0;
        while(lf<=rt){
            if(power>=tokens[lf]){
                power -= tokens[lf++];
                score++;
                max = Math.max(max,score);
            }else if(score>0){
                power += tokens[rt--];
                score--;
            }else break;
        }
        return max;
    }

    static void quickSort(int[] tok, int st, int en){
        if(st<en){
            int pivot = findThePivots(tok, st, en);
            quickSort(tok, st, pivot);
            quickSort(tok, pivot+1, en);
        }
    }

   static int findThePivots(int[] tok, int lf, int rt){
        int pivot = tok[lf];int st=lf; int en=rt;
        while(st<en){
            while( tok[st]<=pivot && st<=rt-1)st++;
            while( tok[en]>pivot && en>=lf+1)en--;
            if(st<en){
                int temp = tok[st];
                tok[st] = tok[en];
                tok[en] = temp;
            }
        }
        int temp = tok[lf];
        tok[lf] = tok[en];
        tok[en] = temp;
        return en;
    }

    public static int lengthOfLongestSubstring(String s) {
        int max = 0;int count = 0;
        if(s.length() == 1)return 1;
        Map<Character,Integer> mp = new HashMap<>();
        for(int i=0;i<s.length();i++){
           char c = s.charAt(i);
            if(!mp.containsKey(c)){
                count++;
                mp.put(c,1);
            }else{
                max =  Math.max(count, max);
                int j = i-1;count = 1;
                mp = new HashMap<>();
                mp.put(c,1);
                while (j>=0 && c != s.charAt(j)) {
                    mp.put(s.charAt(j),1);
                    j--;count++;
                }
            }
        }max =  Math.max(count, max);
        return max;
    }

    public static int threeSumClosest(int[] nums, int target) {
        int count = 0;
        Arrays.sort(nums);
        int i = 0; int a = Integer.MIN_VALUE; boolean check = true;
        while(i<=nums.length-3){
            while(i<nums.length-2 && nums[i] == a)i++;
            a = nums[i];
            int j = i+1;
            int k = nums.length-1;
            int b = nums[j];
            int c = nums[k];
            while (j<k) {
                int sum = a+b+c;
                if (sum < target) {
                    if (!check) {
                        count = Math.max(count, sum);
                        if (count>0 && sum>0 && count-target > target-sum)count = sum;
                    }
                    if(check) {
                        count = sum;
                        check = false;
                    }
                    while (j<k && nums[j] == b) j++;
                    b = nums[j];
                } else if (sum > target) {
                    if (!check) {
                        count = Math.min(count, sum);
                        if(count == target-2 && sum == target+1) count = sum;
                        if (count>0 && sum>0 && target-count > sum-target)count = sum;
                    }
                    if(check) {
                        count = sum;
                        check = false;
                    }
                    while (k>j && nums[k] == c)k--;
                    c = nums[k];
                } else {
                    count = sum; break;
                }
            }
            i++;
        }
        return count;
    }

    public static List<List<Integer>> threeSum(int[] nums) {
        HashSet<List<Integer>> ls = new HashSet<>();
        Arrays.sort(nums);
        int i = 0; int a = Integer.MIN_VALUE;
        while(i<=nums.length-3){
            while(i<nums.length-2 && nums[i] == a)i++;
            a = nums[i];
            int j = i+1;
            int k = nums.length-1;
            int b = nums[j];
            int c = nums[k];

            while (j<k) {
                if (a + b + c == 0) {
                    List<Integer> temp = new ArrayList<>();
                    temp.add(a);
                    temp.add(b);
                    temp.add(c);
                    Collections.sort(temp);
                    ls.add(temp);
                    k--;
                    c = nums[k];
                } else if (a + b + c < 0) {
                    while (j<k && nums[j] == b) j++;
                    b = nums[j];
                } else if (a + b + c > 0) {
                    while (k>j && nums[k] == c)k--;
                    c = nums[k];
                }
            }
            i++;
        }
        List<List<Integer>> res = new ArrayList<>(ls);
        return res;
    }

    public static List<String> wordSubsets(String[] words1, String[] words2) {
//        List<String> res = new ArrayList<>();
//        Map<Character,Integer> mp2 = new HashMap<>();
//        for(int j=0;j<words2.length;j++){
//            Map<Character,Integer> temp = new HashMap<>();
//            for (char c:words2[j].toCharArray()) {//this is for words2
//                temp.put(c,mp2.getOrDefault(c,0)+1);
//            }
//            for (char c: temp.keySet()) {//this is for words2
//                if(mp2.containsKey(c)) mp2.put(c,Math.max(mp2.get(c),temp.get(c)));
//                else mp2.put(c,mp2.getOrDefault(c,0)+1);
//            }
//        }
//        for(int i=0;i<words1.length;i++){
//            boolean check = true;
//            Map<Character,Integer> mp1 = new HashMap<>();
//            for (char c:words1[i].toCharArray()){//this is for words1
//                mp1.put(c,mp1.getOrDefault(c,0)+1);
//            }
//            for (char key:mp2.keySet()){
//                if(mp1.containsKey(key) && (mp1.get(key) >= mp2.get(key))){
//                    continue;
//                } check = false; break;
//            }
//            if(check) res.add(words1[i]);
//        }
//       return res;
        List<String> res = new ArrayList<>();
        int[] w2Array = new int[26];
        for (String w2:words2 ){
            int[] temp = new int[26];
            for (char c:w2.toCharArray() ){
                temp[c-'a']++;
                w2Array[c-'a'] = Math.max(w2Array[c-'a'],temp[c-'a']);
            }
        }
        for (String w1:words1 ){
            int[] w1Array = new int[26];
            for (char c:w1.toCharArray() ){
                w1Array[c-'a']++;
            }
            if(checker(w1Array,w2Array))res.add(w1);
        }
        return res;
    }

    static boolean checker(int[] w1, int[] w2){
        for (int i = 0; i < 26; i++) {
            if(w1[i]<w2[i]) return false;
        }
        return true;
    }

    public static boolean checkSubarraySum(int[] nums, int k) {
        int sum = 0;int total = 0; int index=0;
        for(int i=0;i<nums.length;i++){
            total += nums[i];
            sum += nums[i];
            if(sum == k)return true;
            else if(sum > k) {
                sum -= nums[index];
                index++;
            }
        }
        return total % k == 0;
    }
    static  void iterationInArraySubSet(){
        List<List<Integer>> ls = new ArrayList<>();
        int[] arr = {1,2,3};
        ls. add(new ArrayList<>());
        for (int i:arr ){
            int n = ls.size();
            for (int j = 0; j < n; j++) {
                List<Integer> inner = new ArrayList<>(ls.get(j));
                inner.add(i);
                ls.add(inner);
            }
        }
        System.out.println(ls);
    }

    static  void recInArraySubSet(List<List<Integer>> ls, List<Integer> arr, List<Integer> temp){
        if (arr.isEmpty()){
            List<Integer> inner = new ArrayList<>(temp);
            ls.add(inner);
            return;
        }

        temp.add(arr.get(0));
        List<Integer> a = new ArrayList<>(arr);
        a.remove(0);
        recInArraySubSet(ls, a, temp);
        temp.remove(temp.size()-1);
        recInArraySubSet(ls, a, temp);
    }

    public static String maximumOddBinaryNumber(String s) {
        boolean check = true;
        char[] c = s.toCharArray();
        if(c[s.length()-1] == '1') check = false;
        int i = 0; int j = s.length()-2;
        while(i<j){
            while(j>=0 && c[j] == '0')j--;
            if(j>=0 && check) {
                c[c.length-1] = c[j];
                c[j] = '0';j--;
                check = false;
            }

            if(j>=0 && j>i && c[i] == '0' && c[j] =='1'){
                c[i++] = '1';
                c[j--] = '0';
            }
            if(c[i] =='1') i++;
        } if(j>=0 && check &&  c[c.length-1] == '0' && c[j] == '1') {
            c[c.length-1] = c[j];
            c[j] = '0';
        }
        s = new String (c);
        return s;
    }

    public static int longestOnes(int[] c, int k) {
        int max = 0;
        for (int i = 0; i < c.length; i++) {//aaabbaabbb
            int temp = Math.max((findTheFirstAndSecondMaxLength(c, true, i, k)), (findTheFirstAndSecondMaxLength(c, false, i, k)));
            max = Math.max(max,temp);
            while (i<c.length-1 && c[i] == c[i+1] ) i++;
        }
        return max ;
    }

    private static int findTheFirstAndSecondMaxLength(int[] c, boolean b, int i, int k) {
        int len = 0;
        int[] temp = c.clone();
        if(b && i>=0){
            int start = 0 ;
            if(i-k>=0){
                len=k;
                start = i;
            }else  if(i>0){
                len = i;
                start=i;
            }
            for (int j = start; j < c.length-1; j++) {
                if (c[j] != c[j+1] || c[j] == 0 ) break;
                len++;
            }
            if(c[start] == c[c.length-1] && c[start] == 0) return 0;
            return len+1;
        }else if(!b && i+k <c.length){
            for (int j = i; j < c.length-1; j++) {
                if (temp[j] != 0 && temp[j] != temp[j+1] && k>0  ){
                    temp[j+1] = temp[j];
                    k--;
                }else if (temp[j] != temp[j+1] && k==0 || temp[j] == 0){
                    break;
                }
                len++;
            }
        }if(c[0] == c[c.length-1] && c[0] == 0) return 0;
        return len+1;
    }

    public static int count(int arr[], int x) {
       int count = 0;
       count = findOcuuranceOfNum(arr, 0, arr.length-1, x);
       return count;
    }

    private static int findOcuuranceOfNum(int[] arr, int fr, int en, int t) {
        int count = 0;
        while (fr<en) {
            int mid = fr + (en - fr) / 2;
            if (arr[mid] == t) {
                int i = mid - 1;count++;
                int j = mid + 1;
                while (i>=0 && arr[i] == t){
                    count++;i--;
                }
                while (j<arr.length && arr[j] == t) {
                    count++;j++;
                }
                break;
            } else if (arr[mid] > t) {
                en = mid - 1;
            } else {
                fr = mid + 1;
            }
        }
        return count;
    }

    public static int longestValidParentheses(String s) {
        int leftCount = 0;
        int rightCount = 0;
        int maxLength = 0;
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == '(') {
                leftCount++;
            } else {
                rightCount++;
            }
            if (leftCount == rightCount) {
                maxLength = Math.max(maxLength, 2 * rightCount);
            } else if (rightCount > leftCount) {
                leftCount = rightCount = 0;
            }
        }
        leftCount = rightCount = 0;
        for (int i = s.length() - 1; i >= 0; i--) {
            if (s.charAt(i) == '(') {
                leftCount++;
            } else {
                rightCount++;
            }
            if (leftCount == rightCount) {
                maxLength = Math.max(maxLength, 2 * leftCount);
            } else if (leftCount > rightCount) {
                leftCount = rightCount = 0;
            }
        }
        return maxLength;
    }

    public static double calculateTax(int[][] brackets, int income) {
        if(income == 0) return 0.000;
        double amountOfIncome = brackets[0][0];
        double percentage = brackets[0][1];
        double total = percentage > 0 ? (percentage/100)*amountOfIncome : 0;
        income -= brackets[0][0]; double diff = brackets[0][0];
        for(int i=1;i<brackets.length && income>0 ;i++){
            amountOfIncome = 0;
            if(brackets[i][0] - brackets[i-1][0] <= income){
                amountOfIncome = brackets[i][0] - brackets[i-1][0];
                diff = amountOfIncome;
                income -= diff;
            }else {
                amountOfIncome = income;
                income = 0;
            }
            percentage = brackets[i][1];
            double amt =  percentage > 0 ? (percentage/100)*amountOfIncome : 0;
            total += amt;
        }
        return total;
    }
    public static int characterReplacement(String s, int k) {
//        for(int i=1;i<s.length();i++){
//            if(c[i-1] == c[i]){
//                len++;
//            }else if(c[i-1] != c[i] && dupe > 0){
//                c[i] = c[i-1];
//                len++;
//                dupe--;
//            }else{
//                max = Math.max(max, len);
//                len = 1;
//                dupe = k;
//            }
//        }
//       if(len>max)max=len;
        int max = 0;
        char[] c = s.toCharArray();
        for (int i = 0; i < c.length; i++) {//aaabbaabbb
           int temp = Math.max((findTheFirstAndSecondMaxLength(c, true, i, k)), (findTheFirstAndSecondMaxLength(c, false, i, k)));
           max = Math.max(max,temp);
           while (i<c.length-1 && c[i] == c[i+1] ) i++;
        }
        return max;
    }

    private static int findTheFirstAndSecondMaxLength(char[] c, boolean b, int i, int k) {
      int len = 0;
      char[] temp = c.clone();
      if(b && i>=0){
          int start = 0 ;
          if(i-k>=0){
              len=k;
              start = i;
          }else  if(i>0){
              len = i;
              start=i;
          }
          for (int j = start; j < c.length-1; j++) {
              if (c[j] != c[j+1]) break;
              len++;
          }
          return len+1;
      }else if(!b && i+k <c.length){
          for (int j = i; j < c.length-1; j++) {
              if (temp[j] != temp[j+1] && k>0){
                  temp[j+1] = temp[j];
                  k--;
              }else if (temp[j] != temp[j+1] && k==0){
                  break;
              }
              len++;
          }
      }
      return len+1;
    }

    public static List<Integer> majorityElement11(int[] nums) {
        ArrayList<Integer> ls = new ArrayList<>();
        if(nums.length <= 2 ) {
            if(nums.length == 1) {
                ls.add(nums[0]);
                return ls;
            } if(nums[0]==nums[1]) {
                ls.add(nums[1]);
                return ls;
            }else {
                ls.add(nums[0]);
                ls.add(nums[1]);
                return ls;
            }
        }int temp = nums.length/3;
        // Map<Integer,Integer> mp = new HashMap<>();
        // for(int i=0;i<nums.length;i++){
        //     mp.put(nums[i],mp.getOrDefault(nums[i],0)+1);
        //         if(mp.get(nums[i]) == temp+1) {
        //             ls.add(nums[i]);
        //         }
        // }

        //2nd approach
        //Arrays.sort(nums);
        qSortArray(nums, 0, nums.length-1);
        System.out.println(Arrays.toString(nums));
        int len = 1;
        for(int i = 1; i<nums.length;i++){
            if(nums[i-1] == nums[i]) {
                len++;
            }else {
                if(len>temp)ls.add(nums[i-1]);
                len=1;
            }
        }
        if(len>temp)ls.add(nums[nums.length-1]);
        return ls;
    }

   static void qSortArray(int[] arr, int lf, int rt){
        if(lf<rt){
            int pivot = findThePivot(arr, lf, rt);
            qSortArray(arr, lf, pivot-1);
            qSortArray(arr, pivot+1, rt);
        }
    }

   static int findThePivot(int[] arr, int lf, int rt){
        int pivot = arr[lf];
        int i = lf;
        int j = rt;
        while(i<j){
            while(arr[i] <= pivot && i<=rt-1) i++;
            while(arr[j] > pivot && j>=lf+1) j--;
            if(i<j) swapTheIndex(arr, i, j);
        }
        swapTheIndex(arr, lf, j);
        return j;
    }

    static void swapTheIndex(int[] arr, int i, int j){
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

    public static int longestConsecutive(int[] nums) {
        Arrays.sort(nums);
        int len = 1;int max = 0;
        for(int i=1;i<nums.length;i++){
            if(nums[i-1]+1 == nums[i]) len++;
            else {
                max = Math.max(max,len);
                len = 0;
            }
        }
        if(len>max) max=len;
        return max;
    }

    public static int longestSubarrayWithSumK(int []a, long k) {
//        int sum = 0;int max= 0;int i = 0;
//        for(int in = 0;in<a.length;in++){
//            sum += a[in];
//            if(a[in] == k){
//                max = Math.max(max,1);
//                sum = 0;
//               // i=in+1;
//            }
//            if(k == sum){
//                max = Math.max(max,in-i+1);
//                sum = 0;
//                i=in+1;
//            }else if(sum>k){
//                sum = 0;
//                i=in+1;//1,
//            }
//        }

        //Two Pointer Approch
        int i =0;int j=0;int sum = 0;int max = 0;
        while(i<=j && j<a.length){
            sum += a[j];
            if(k==sum){
                max = Math.max(max,j-i+1);
            } else if ( k<sum) {
                sum -= a[i];
                i++;
            }
            j++;
        }
        while(i<j){
            if(k==sum){
                max = Math.max(max,j-i+1);i++;
            } else if ( k<sum) {
                sum -= a[i];
                i++;
            }
        }
        return max;
    }

    public static List< Integer > sortedArray(int []a, int []b) {
        // Write your code here
        Set<Integer> ls = new LinkedHashSet<>();
        int i = 0; int j = 0;
        for(int k=0;k<a.length+b.length;k++){
            if(i<a.length && j<b.length && a[i] == b[j]) {
                ls.add(a[i++]);j++;
            }else if(i<a.length && j<b.length  && a[i] < b[j] ) {
                ls.add(a[i++]);
            }else if(j<b.length) {
                ls.add(b[j++]);
            }
        }
        while(i<a.length){
            ls.add(a[i++]);
        }
        while(j<b.length){
            ls.add(b[j++]);
        }
        List<Integer> temp = new ArrayList<>();
        for (int num:ls )temp.add(num);
        return temp;
    }

    public static ArrayList<Integer> rotateArray(ArrayList<Integer> arr, int k) {
        swapTheArray(arr, 0, k-1);
        swapTheArray(arr, k, arr.size()-1);
        swapTheArray(arr, 0, arr.size()-1);
        return arr;
    }
    static void swapTheArray(ArrayList<Integer> arr, int fr, int en){
        while(fr<en){
            int temp = arr.get(fr);
            arr.set(fr, arr.get(en));
            arr.set(en, temp);
            fr++; en--;
        }
    }

    public static int[] moveZeros( int []a) {
        int i = 0;int j = 1;
        while(i<j && j<a.length){
            while(j>i && i<a.length){
                if(a[i] != 0) i++;
                else break;
            }j=i+1;
            while(j<a.length){
                if(a[j] == 0) j++;
                else break;
            }
            if(i<a.length && j<a.length && i!=j && a[i]==0){
                a[i] = a[j];
                a[j] = 0;
            }
        }
        return a;
    }

    public static int[] getSecondOrderElements(int[] a) {
        int[] temp = {a[0],Integer.MAX_VALUE};
        int max = a[0];int low = Integer.MAX_VALUE;

        for (int i = 0; i < a.length; i++) {
            if(max < a[i]) {
                temp[0]=max;
                max=a[i];
            } else if (max > a[i] && a[i] > temp[0]) {
                temp[0] = a[i];
            }
            if(low>a[i]){
                temp[1] = low;
                low = a[i];
            }else if (low < a[i] && a[i] < temp[1]) {
                temp[1] = a[i];
            }
        }
        return temp;

    }
    public static int pivotIndex(int[] nums) {
        // for(int i=0;i<nums.length;i++){
        //     int index = i;
        //     int leftSum = sumOfArr(nums, 0, i);
        //     int rightSum = sumOfArr(nums, i+1, nums.length);
        //     if(leftSum == rightSum) return i;
        // }
        int totalCount=0; int[] leftCount = new int[nums.length];
        for(int i=0;i<nums.length;i++){
            totalCount += nums[i];
            leftCount[i] = totalCount;
        }
        for(int i=0;i<nums.length;i++){
            int lf = leftCount[i]-nums[i];
            int rt = totalCount-lf-nums[i];
            if(lf==rt)return i;
        }
        return -1;
    }

    public static int singleNonDuplicate(int[] nums) {
        for(int i=1;i<nums.length;i +=2){
            if(nums[i] != nums[i-1] ) return nums[i-1];
        }
        return 0;
    }

    public static int subarraySum(int[] nums, int k) {
//        int sum = 0; int count = 0;
//        if(nums.length < 2) return 0;sum = nums[0];
//        for(int i=1;i<nums.length;i++){
//            sum += nums[i];
//            if(nums[i] == k)count++;
//            if(nums[i] + nums[i-1] == k && i>1)count++;
//            if(sum == k ){
//                count++;
//                //sum = 0;
//            }else if(sum > k){
//                sum = nums[i];
//            }
//        }
//        return count;
        int count=0;
        int n = nums.length;
        int[] prefix = new int[n];
        prefix[0] = nums[0];

        for (int i = 1; i < n; i++) {
            prefix[i] = nums[i] + prefix[i - 1];
        }
        Map<Integer,Integer> map = new HashMap<>();
        //int sum = 0;if(nums[0] == k)count++;
        for(int i = 0; i<nums.length; i++){
            if(prefix[i] == k)count++;
            //if(nums[i] + nums[i-1] == k )count++;
            if(map.containsKey(k-prefix[i])){
                count+=map.get(k-prefix[i]);
            }
            map.put(prefix[i],map.getOrDefault(prefix[i],0)+1);
        }
        return count;
    }
    public static void rotateTraverse(int[][] matrix) {
        int row =0;
        int col =0;
//       int[] temp = new int[matrix.length];
//        while(row<matrix.length && col< matrix.length){
//            while (row < matrix.length){
//                temp[row] = matrix[row][col];
//                row++;
//            }
//            int assign = 0;
//            if(row == matrix.length){//0,3 0,2 0,1 0,0
//                matrix[assign][col] = matrix[--row][col];
//                matrix[col][row] = temp[assign++];
//            }
//            col++;
//        }

        while(row<matrix.length && col< matrix.length){
            while (row < matrix.length){
                int temp = matrix[row][col];
                matrix[row][col] = matrix[col][row];
                matrix[col][row] = temp;
                row++;
            }
            col++;row=col;
        }
        col = 0; row = 0;
        while(row<matrix.length){
            int st = 0; int en = matrix.length-1;
            while (col < matrix.length-1-col){
                int temp = matrix[row][col];
                matrix[row][col] = matrix[row][matrix.length-1-col];
                matrix[row][matrix.length-1-col] = temp;
                col++;
            }
            row++;col=0;
        }

        for (int[] ints : matrix) {
            for (int j = 0; j < matrix.length; j++) {
                System.out.print(ints[j] + " ");
            }
            System.out.println();
        }
    }

    public static void setZeroes(int[][] matrix) {

        for(int i=0;i<matrix.length;i++){
            for(int j=0;j<matrix[i].length;j++){
                if(matrix[i][j] == 0){
//                    matrix[i][j] = -1;
//                    setZeroFOrRowsAndColuns(matrix, i, j);
                }
            }
        }
        for(int i=0;i<matrix.length;i++){
            for(int j=0;j<matrix[i].length;j++){
                if(matrix[i][j] == -1){
                    matrix[i][j] = 0;
                }
            }
        }
        for(int i=0;i<matrix.length;i++){
            for(int j=0;j<matrix[i].length;j++){
                System.out.print(matrix[i][j]+" ");
            }
            System.out.println();
        }
    }

    static void setZeroFOrRowsAndColuns(int[][]matrix, int row, int col){
        // row zero
        for(int i=0;i<matrix.length;i++){
            if(matrix[i][col]!=0)
              matrix[i][col]=-1;
        }
        for(int j=0;j<matrix[row].length;j++){
            if(matrix[row][j]!=0)
                matrix[row][j]=-1;
        }
    }

    public static int maxPower(String s) {
        if(s.isEmpty())return 0;
        if(s.length() == 1)return 1;
        int count =1;
        int max = 0;
        for(int i=1;i<s.length();i++){
            if(s.charAt(i-1) == s.charAt(i))count++;
            else{
                if(max<count){
                    max=count;
                } count=1;
            }
        }
        if(max<count){
            max=count;
        }
        return max;
    }

    public static int findKthLargest(int[] nums, int k) {
        HashSet<Integer> hs = new HashSet<>();
        for (int i:nums)hs.add(i);
        int s = (int) hs.toArray()[0];
        System.out.println(hs);

        //Using heap data type
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        for (int i = 0; i < k; i++) {
            pq.add(nums[i]);
        }System.out.println(pq);

        for (int i = k; i <nums.length ; i++) {
            if( nums[i] > pq.peek()) {
                pq.poll();
                pq.add(nums[i]);
            }
        }
        System.out.println(pq.poll());
//        int count = 0;
//        k=nums.length-k;
//        while(!pq.isEmpty()){
//            if(count==k) {
//                System.out.println(pq.peek());break;
//            }
//            pq.poll();count++;
//        }
//        System.out.println(pq);

        //Using  predefined functions
//        Arrays.sort(nums);
//        System.out.println(nums[nums.length-k]);
        return nums[nums.length-k+1];
    }

    public static int percentageLetter(String s, char letter) {
        int per = 0;
        for (int i = 0; i <s.length() ; i++) {
            if(s.charAt(i) == letter) per++;
        }
        per = (per*100)/s.length();
        System.out.println(per);
        return per;
    }

    public static List<String> topKFrequent(String[] words, int len) {
        HashMap<String,Integer> map = new HashMap<>();
        for(String i:words ) map.put(i, map.getOrDefault(i,0)+1);
        String[] values = new String[map.size()];
        int[] count = new int[map.size()];int j=0;
        for (Map.Entry<String, Integer> i:map.entrySet()) {
            values[j] = i.getKey();
            count[j++] = i.getValue();
        }
        //Sorting as per the count of values
        for (j=0;j< count.length-1;j++){
            int temp = count[j];
            for (int i = j+1; i < count.length; i++) {
                if(temp == count[i]){
                    if(values[i].charAt(0) == values[j].charAt(0)){
                        boolean check = true; int ch = 0; boolean exitsLen = false;
                        while(check){
                            if( ch < values[j].length() && ch < values[i].length() && values[i].charAt(ch) == values[j].charAt(ch)) ch++;
                            else {
                                check = false;
                                if(ch >= values[j].length() || ch >= values[i].length()) exitsLen = true;
                            }
                        }
                        if(exitsLen){
                            if(values[i].length() < values[j].length()) {
                                String valTemp = values[j];
                                values[j] = values[i];
                                values[i] = valTemp;

                                count[j] = count[i];
                                count[i] = temp;
                            }
                        }
                        if(values[i].charAt(ch) < values[j].charAt(ch)){
                            String valTemp = values[j];
                            values[j] = values[i];
                            values[i] = valTemp;

                            count[j] = count[i];
                            count[i] = temp;
                        }
                    }else if(values[i].charAt(0) < values[j].charAt(0)){
                        String valTemp = values[j];
                        values[j] = values[i];
                        values[i] = valTemp;

                        count[j] = count[i];
                        count[i] = temp;
                    }
                }else if(temp<count[i]){
                    String valTemp = values[j];
                    values[j] = values[i];
                    values[i] = valTemp;

                    count[j] = count[i];
                    count[i] = temp;
                }temp = count[j];
            }
        }j=0;
        List<String> res = new ArrayList<>();
        for (int i = 0; i < len; i++) {
            res.add(values[i]);
        }
        System.out.println((res));
        return res;
    }

    public static int[] topKFrequent(int[] nums, int len) {
        HashMap<Integer,Integer> map = new HashMap<>();
        for(int i:nums ) map.put(i, map.getOrDefault(i,0)+1);
        int[] values = new int[map.size()];
        int[] count = new int[map.size()];int j=0;
        for (Map.Entry<Integer, Integer> i:map.entrySet()) {
            values[j] = i.getKey();
            count[j++] = i.getValue();
        }
        //Sorting as per the count of values
        for (j=0;j< count.length-1;j++){
            int temp = count[j];
            for (int i = j+1; i < count.length; i++) {
                if(temp == count[i]){
                    if(values[i] > values[j]) {
                        int valTemp = values[j];
                        values[j] = values[i];
                        values[i] = valTemp;

                        count[j] = count[i];
                        count[i] = temp;
                    }
                }else if(temp<count[i]){
                    int valTemp = values[j];
                    values[j] = values[i];
                    values[i] = valTemp;

                    count[j] = count[i];
                    count[i] = temp;
                }temp = count[j];
            }
        }j=0;
        int[] res = new int[len];
        for (int i = 0; i < len; i++) {
            res[i] = values[i];
        }
//        for (int i = 0; i < nums.length;) {
//            for (int k = 1; k <= count[j] ; k++) {
//                nums[i++] = values[j];
//            }j++;
//        }
        System.out.println(Arrays.toString(res));
        return nums;
    }
    public static String frequencySort(String s) {
        char[] nums = s.toCharArray();
        HashMap<Character,Integer> map = new HashMap<>();
        for(char i:nums ) map.put(i, map.getOrDefault(i,0)+1);
        char[] values = new char[map.size()];
        int[] count = new int[map.size()];int j=0;
        for (Map.Entry<Character, Integer> i:map.entrySet()) {
            values[j] = i.getKey();
            count[j++] = i.getValue();
        }
        //Sorting as per the count of values
        for (j=0;j< count.length-1;j++){
            int temp = count[j];
            for (int i = j+1; i < count.length; i++) {
                if(temp == count[i]){
                    if(values[i] > values[j]) {
                        char valTemp = values[j];
                        values[j] = values[i];
                        values[i] = valTemp;

                        count[j] = count[i];
                        count[i] = temp;
                    }
                }else if(temp<count[i]){
                    char valTemp = values[j];
                    values[j] = values[i];
                    values[i] = valTemp;

                    count[j] = count[i];
                    count[i] = temp;
                }temp = count[j];
            }
        }j=0;
        for (int i = 0; i < nums.length;) {
            for (int k = 1; k <= count[j] ; k++) {
                nums[i++] = values[j];
            }j++;
        }
        s = new String(nums);
        return s;
    }

    public static int[] frequencySort(int[] nums) {
        HashMap<Integer,Integer> map = new HashMap<>();
        for(int i:nums ) map.put(i, map.getOrDefault(i,0)+1);
        int[] values = new int[map.size()];
        int[] count = new int[map.size()];int j=0;
        for (Map.Entry<Integer, Integer> i:map.entrySet()) {
            values[j] = i.getKey();
            count[j++] = i.getValue();
        }
        //Sorting as per the count of values
        for (j=0;j< count.length-1;j++){
            int temp = count[j];
            for (int i = j+1; i < count.length; i++) {
                 if(temp == count[i]){
                     if(values[i] > values[j]) {
                         int valTemp = values[j];
                         values[j] = values[i];
                         values[i] = valTemp;

                         count[j] = count[i];
                         count[i] = temp;
                     }
                 }else if(temp<count[i]){
                    int valTemp = values[j];
                    values[j] = values[i];
                    values[i] = valTemp;

                    count[j] = count[i];
                    count[i] = temp;
                }temp = count[j];
            }
        }j=0;
        for (int i = 0; i < nums.length;) {
            for (int k = 1; k <= count[j] ; k++) {
                nums[i++] = values[j];
            }j++;
        }
        System.out.println(Arrays.toString(nums));
        return  nums;
    }


    public static int[][] sortTheStudents(int[][] score, int k) {
        for (int row = 0; row < score.length; row++) {
            int temp = score[row][k];
            for (int i = row+1; i < score.length; i++) {
                if(temp<score[i][k]){
                    swapRows(row,i, score[row].length, score);
                }temp = score[row][k];
            }

        }
        for (int i = 0; i < score.length; i++) {
            for (int j = 0; j < score[i].length ; j++) {
                System.out.print(score[i][j]+" ");
            }
            System.out.println();
        }
        return score;
    }

    static void swapRows(int row1, int row2, int rowLen, int[][] score){
        for (int i = 0; i < rowLen; i++) {
            int temp = score[row1][i];
            score[row1][i] = score[row2][i];
            score[row2][i] = temp;
        }
    }

    public static String[] sortPeople(String[] names, int[] h) {
//        for(int i=0;i<heights.length;i++){
//            int temp = heights[i];
//            for(int j=i+1;j<heights.length;j++){
//                if(temp < heights[j]){
//                    String s = names[i];
//                    names[i] = names[j];
//                    names[j] = s;
//
//                    heights[i] = heights[j];
//                    heights[j] = temp;
//                    temp = heights[i];
//                }
//            }
//        }
        Map<Integer,String> map = new TreeMap<>();
        int j=0;
        for(int i: h) map.put(i,names[j++]); int k=map.size()-1;
        for(int i: map.keySet()) {
            names[k]=map.get(i);k--;
        }
        return names;
    }
    public static int removeDuplicates(int[] nums) {
        HashMap<Integer,Integer> ls = new HashMap<>();
        int[] arr = new int[nums.length];int j=0;
        for(int i=0;i<nums.length;i++){
            if(!ls.containsKey(nums[i])) arr[j++] = nums[i];
            ls.put(nums[i], ls.getOrDefault(nums[i],0)+1);
        }
        int count =0;
        if(!ls.isEmpty()){
            for (int i = 0; ls.size() > 0 && i < arr.length; i++) {
                int key = arr[i];
                if(ls.get(key)>1){
                    for (int k = 0; k < 2; k++) {
                        nums[count++]=key;
                    }
                }else {
                    nums[count++]=key;
                }
                ls.remove(key);
            }
        }
        return count;
    }

    public static int findMin(int[] nums) {
        int st = 0;
        int en = nums.length-1;
        while(st<en){
            int mid = st+(en-st)/2;
            if(nums[st] > nums[mid]) en=mid-1;
            else if(nums[mid] > nums[mid+1]) return nums[mid+1];
            else st=mid+1;
        }
        return  st;
        //return st+1 >= nums.length ? nums[0] : nums[st+1];
    }

    public static void rotate(int[] nums, int k) {
        k = k%nums.length;
        if(k<0) k +=nums.length;
        rotatingParts(nums, 0, nums.length-k-1);
        rotatingParts(nums, nums.length-k, nums.length-1);
        rotatingParts(nums, 0, nums.length-1);
    }

    static void rotatingParts(int[] nums, int st, int en){
        while(st<en){
            int temp = nums[st];
            nums[st] = nums[en];
            nums[en] = temp;
            st++; en--;
        }
    }

    private static void spiralMatrix(int col, int row) {
        int[][] matrix = new int[4][4];
        HashSet<List<Integer>> ls = new HashSet<>();
        List<int[]> arr= new ArrayList<>();
        int count = 1; int i=0;
        matrix[col][row]=count++;
        char c = 'r'; row++;
        while(count<=matrix.length*matrix.length){
            switch (c){
                case 'r':{
                    arr.add(new int[]{col,row});
                    if(!ls.contains(arr.get(i))){
                       matrix[col][row] = count++;
                       if(col>=0 && col<matrix.length-1) col++;
                        i++;
                       c='d';
                    }else {


                        //arr.remove(i);
                    }
                    break;
                }
                case ('d'):{
                    arr.add(new int[]{col,row});
                    if(!ls.contains(arr.get(i))){
                        i++;
                        matrix[++col][row] = count++;
                        c='l';
                    }else {
                        arr.remove(i);
                    }
                    break;
                }
                case 'l':{
                    arr.add(new int[]{col,row});
                    if(!ls.contains(arr.get(i))){
                        i++;
                        matrix[col][--row] = count++;//1,0
                        c='u';
                    }else {
                        arr.remove(i);
                    }
                    break;
                }
                case ('u'):{
                    arr.add(new int[]{col,row});
                    if(!ls.contains(arr.get(i))){
                        i++;
                        matrix[++col][row] = count++;
                        c='l';
                    }else {
                        arr.remove(i);
                    }
                    break;
                }
            }
        }

    }

    public static double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int len = nums1.length + nums2.length;String s = new String(Arrays.toString(nums1));
        if(s.indexOf(s.charAt(0)) - s.lastIndexOf(s.charAt(0)) == 0){

        }
        int[] arr = new int[len];
        int j=0; int k=0;
        for(int i=0;i<arr.length;i++){
            int temp1=Integer.MAX_VALUE;
            int temp2=Integer.MAX_VALUE;
            if(nums1.length > j) temp1 = nums1[j];
            if(nums2.length > k) temp2 = nums2[k];

            if(temp1<temp2){
                arr[i] = temp1;
                j++;
            }else{
                arr[i] = temp2;
                k++;
            }
        }
        System.out.println(Arrays.toString(arr));
        if(len%2!=0){
            int temp = arr[arr.length/2];
            double d = (double)temp;
            System.out.println(d);
            return d;
        }else{
            double temp = (double) (arr[arr.length / 2] + arr[(arr.length / 2) - 1]) / 2;
            double d = (double)temp;
            System.out.println(temp);
            return d;
        }
    }
    public static int[][] spiralMatrix(int m, int n, ListNode head) {
        int[][] matrix = new int[m][n];
        int count = 1;
        int i = 0;
        char c = 'l';
        int col = 0;
        int row = 0;
        while (count<=matrix.length*matrix[0].length){
            switch (c){
                case 'l' :{
                    for ( col=col ;col < matrix[row].length-i; col++) {
                        matrix[row][col]=head.val ;
                        count++;
                        head = head.next == null ? new ListNode(-1) : head.next;
                    }
                    row++;
                    col--;
                    c='d';
                    break;
                } case 'd':{
                    for (int j = row; row < matrix.length-i; row++) { //5
                        matrix[row][col]=head.val ;
                        count++;
                        head = head.next == null ? new ListNode(-1) : head.next;
                    }
                    c='r';
                    row--;
                    col--;
                    break;
                } case 'r':{
                    for ( col=col ;col>=i; col--) {
                        matrix[row][col]=head.val ;
                        count++;
                        head = head.next == null ? new ListNode(-1) : head.next;
                    }
                    row --;
                    col ++;
                    c='u';
                    i++;
                    break;
                } case  'u':{
                    for ( row=row ;row>=i; row--) {
                        matrix[row][col]=head.val ;
                        count++;
                        head = head.next == null ? new ListNode(-1) : head.next;
                    }
                    row++;
                    col++;
                    c='l';
                    break;
                }
            }
        }
        return matrix;
    }

    public static List<Integer> spiralOrder(int matrix[][]) {
        List<Integer> ls = new ArrayList<>();
        int count = 1;
        int i = 0;
        char c = 'l';
        int col = 0;
        int row = 0;
        while (count<=matrix.length*matrix[0].length){
            switch (c){
                case 'l' :{
                    for ( col=col ;col < matrix[row].length-i; col++) {
                        ls.add(matrix[row][col]);
                        matrix[row][col]=count++;
                    }
                    row++;
                    col--;
                    c='d';
                    break;
                } case 'd':{
                    for (int j = row; row < matrix.length-i; row++) { //5
                        ls.add(matrix[row][col]);
                        matrix[row][col]=count++;
                    }
                    c='r';
                    row--;
                    col--;
                    break;
                } case 'r':{
                    for ( col=col ;col>=i; col--) {
                        ls.add(matrix[row][col]);
                        matrix[row][col]=count++;
                    }
                    row --;
                    col ++;
                    c='u';
                    i++;
                    break;
                } case  'u':{
                    for ( row=row ;row>=i; row--) {
                        ls.add(matrix[row][col]);
                        matrix[row][col]=count++;
                    }
                    row++;
                    col++;
                    c='l';
                    break;
                }
            }
        }
        return ls;
    }

    public static int[][] divideArray(int[] nums, int k) {
        int[][] arr = new int[nums.length/3][3];
        if(nums.length % 3 != 0) return new int[][]{};
        Arrays.sort(nums);
        List<Integer> ls = new ArrayList<>();int col =0;
        for(int i=0;i<=nums.length-3;i +=3){
            if(nums[i+2] - nums[i] <= k){
                arr[col][0] = nums[i];
                arr[col][1] = nums[i+1];
                arr[col][2] = nums[i+2];col++;
            }else{
                return new int[][]{{}};
            }
        }
        return arr;
    }



    public static int findLeastNumOfUniqueInts(int[] arr, int k) {
        Map<Integer, Integer> count = new HashMap<>();
        for (int i = 0; i < arr.length; i++) {
            count.put(arr[i], count.getOrDefault(arr[i], 0) + 1);
        }
        int unique = count.size();
        int[] countArray = new int[100000];
        for(Integer key : count.keySet()) {
            int keyCount = count.get(key);
            countArray[keyCount]++;
        }
        for (int i = 1; i < 100000; i++) {
            if (countArray[i]!= 0) {
                int remove = k / i;
                if (remove == 0) {
                    break;
                } else {
                    remove = Math.min(remove, countArray[i]);
                    unique -= remove;
                    k -= remove * i;
                }
            }
        }
        return unique;
    }

  static   boolean rec1306(int arr[], int k){
        if(arr[k] == 0) return true;
        if(arr[k] == -1) return false;
        int temp = arr[k];
        if(k+temp >= arr.length){
            arr[k] = -1;
            int big = Math.max(k,temp);
            int small = Math.min(k,temp);
            int dif = big - small;
            return rec1306(arr, dif);
        }else{
            arr[k] = -1;
            return rec1306(arr, k+temp);
        }
    }

    public static int singleNumber(int[] nums) {
        HashMap<Integer,Integer> ls = new HashMap<>();
        if(nums.length == 1) return nums[0];
        for(int i =0;i<nums.length;i++){
            ls.put(nums[i],ls.getOrDefault(nums[i],0)+1);
        }

        for(int i : nums){
            if(ls.get(i) == 1) return i;
        }
        return 0;
    }



    private static int jumpMediumGame(int[] arr) {
        int jump = 1;
        int last = 0;
        int max = 0;
        for (int i=0;i< arr.length;i++){
            max = Math.max(max,i+arr[i]);
            if(i==last) {
                last=max;
                jump++;
                if (max >= arr.length - 1) return jump;
            }
        }
        return jump;
    }



    public static List<Integer> findAnagrams(String s, String p) {
        List<Integer> ls = new ArrayList<>();
        char c[] = p.toCharArray();
        Arrays.sort(c);
        String ps = new String(c);
        for(int i=0;i<=s.length()-p.length();i++){
            char cc[] = s.substring(i,i+p.length()).toCharArray();
            Arrays.sort(cc);
            String ss = new String(cc);
            if(ss.equals(ps)) ls.add(i);
        }
        return ls;
    }

    private static void plusOnePrb(int[] arr) {
        int sum = 0;
        int check = 0;
        for(int i=arr.length-1;i>=0;i--){
            sum = sum * 10 + arr[i];
            if(arr[i]<9) i = -1;
        }
        int reSum =0;
        while(sum>0){
            reSum = (reSum*10)+(sum % 10);
            sum/=10;
        }
        check = reSum;
        reSum = reSum+1;
        if(String.valueOf(check).length() != String.valueOf(reSum).length()){
            int ar[] = new int[arr.length+1];
            for(int i =ar.length-1;i>=0;i--){
                ar[i] = reSum%10;
                reSum/=10;
            }
            System.out.println(Arrays.toString(ar));
        }else{
            for(int i =arr.length-1;i>=0 && reSum > 0;i--){
                arr[i] = reSum%10;
                reSum/=10;
            }
            System.out.println(Arrays.toString(arr));
        }
    }

    public static int majorityElement(int[] nums) {
        Map<Integer,Integer> map = new HashMap<>() ;
        for(int i=0;i<nums.length;i++){
            map.put(nums[i], map.getOrDefault(nums[i],0)+1);
        }
        for(int i=0;i<nums.length;i++){
            if(map.get(nums[i])>nums.length/2)
                return nums[i];
        }
        return 0;
    }

    public static List<List<String>> groupAnagrams(String[] strs) {
        List<List<String>> ls = new ArrayList<>();
        List<String> ar = new ArrayList<>();
        HashMap<String,List<String>> hmap = new HashMap<>();
        for(int i=0;i<strs.length;i++){
            char [] c = strs[i].toCharArray();
            Arrays.sort(c);
            String s = new String(c);
            ar.add(strs[i]);
            List<String> list = hmap.getOrDefault(s, new ArrayList<>()); // Get the list associated with the key or create a new list if it doesn't exist
            list.addAll(Arrays.asList(strs[i])); // Add values to the list
            hmap.put(s, list);
        }
        for (List<String> values : hmap.values()) {
            ls.add(values); // Add values to the main list
        }
        return ls;
    }

    public static List<String> removeAnagrams(String[] words) {
        List<String> ls = new ArrayList<>();
        HashMap<String,List<String>> hmap = new HashMap<>();
        for(int i=0;i<words.length;i++){
            char c[] = words[i].toCharArray();
            Arrays.sort(c);
            String s = new String(c);
            if(!hmap.containsKey(s)){
                List<String> list = hmap.getOrDefault(s, new ArrayList<>());
                list.add(words[i]);
                hmap.put(s,list);
                ls.add(words[i]);
            }
        }

//        for (List<String> values : hmap.values()) {
//            ls.add(values.get(0)); // Add values to the main list
//        }
        return ls;
    }

    public static int minSteps(String s, String t) {
        int ch[] = new int[26];
        for(int i=0;i<s.length();i++){
            ch[s.charAt(i)-'a']++;
            ch[t.charAt(i)-'a']--;
        }
        int count =0 ;
        for(int i:ch){
            if(i>0)count=count+i;
            else if(i<0) count = count + (-i);
        }
        return count/2;
    }

    public static List<Integer> spiralOrder() {
        List<Integer> ls = new ArrayList<>();
        int[][] matrix = {{}};
        int count = 1;
        for(int i=0;i<matrix.length;i++){
            for(int j=0;j<matrix[i].length;j++){
                System.out.print(count++);
            }
            System.out.println();
        }
        return new ArrayList<>();
    }
}
